Aplicando css:
Hay 3 formas de aplicar css a tu archivo HTML
Forma EXTERNA: dentro de la etiqueta <head>, 
llamas al archivo CSS que necesites (recuerda el uso de rutas relativas y absolutas).
Forma INTERNA: es recomendable que esté dentro de la etiqueta <head>. 
Puede estar en <body>, pero sería más desprolijo.
Otra forma INTERNA, muy poco recomendable, consiste en usar para “parches” específicos, 
o pruebas. Se hace difícil mantenerlo.
Para poder aplicar css a las etiquetas deberas respetar el formato de css, el formato de css:
selector {
propiedad1: valor;
propiedad2: valor;
}
Un ejemplo simple es:
h1{
color: red;
}
esta forma tiene muy poco grado de especificidad a la hora de aplicar css, en toltal hay 3 formas de especificar una etiqueta,
los grados de especificidad son representadas por numeros 0,0,0.
el primer grado de especificidad son presentadas a llamarlas por su etiqueta ejmeplo: 
h1{
color: red;
}
esto tiene un grado de especificidad de 0,0,1.
el segundo grado de especificidad son representadas al llamarlas por una clase, para aplicar una clase debes usar el atributo "class", y luego colocar en el valor el nombre de la clase ejemplo:
HTML:
<h1 class="titulo">HOLA MUNDO<h1/>
CSS:
.titulo{
color: red;
}
esto tiene un grado de especificidad de 0,1,0.
El tercer grado de especificidad son representados al llamarlos por un id, Para aplicar un ID en el HTML, debes usar el atributo "id", y luego en el valor el nombre del ID ejemplo:
HTML:
<h1 id="titulo">HOLA MUNDO<h1/>
CSS:
#titulo{
color: red;
}
esto tiene un grado de especificidad de 1,0,0.
Sin embargo las 2 tienen diferentes formas para ser utilizadas
ID: sirve para nombrar secciones, divisiones de código 
CLASS: Especificar diseño aparte del codigo 
aunque tiene mas utilidad el atributo class ya que se puede reutilizar su nombre en el HTML y se puede usar varias veces en un atributo en el HTML, mientras que el tributo ID no.
tambien se peude utilizar la declaracion !important; corta la precedencia. Se escribe después del valor de la propiedad CSS que se quiere convertir en la mas importante.
RESET CSS : Los reset CSS contienen en su código fuente definiciones para propiedades problemáticas, que los diseñadores necesitan unificar desde un principio.
Por ejemplo, la mayoría de navegadores establece un margen por defecto entre el contenido de la página web y su propia ventana, cuyo valor varía de un navegador a otro.
Para subsanar esa diferencia, los diseñadores y las diseñadoras de sitios webs suelen declarar la siguiente línea al comienzo de sus hojas de estilo:
*{
margin:0;
padding:0;
}
Primeras propiedades:
Color:Existen distintos valores, pero nos centraremos en 3:
Por nombre del color(ej:red)
Hexadecimal (ej: #ffffff).
RGB (por ejemplo: 50, 212, 227). Si agregas un valor más, puedes manejar su opacidad. (red, green, blue) cada color permite hasta 256 valores.
Estilo Lista:Aplicando esta propiedad y este valor, vamos a poder eliminar las bullets y los números.
list-style-type
ejemplo:
ol{
list-style-type
}
Estilo texto:
font-style: sirve para cambiar el estilo de letra ejemplo:
.normal{
font-stytle: normal;
}
.italica {
font-style:italic;
}
font-weight:sirve para poner los textos en negrita o normal ejemplo:
.negrita {
font-weight:bold;
}
.normal {
font-weight:normal;
}
font_family:sirve para cambiar las fuentes de tipografia ejemplo:
.impact {
font-family:Impact,sans-serif;
}
.comicSans{
font-family:"Comic Sans MS", sans-serif;
}
text-align:sirve para ubicar los textos ejemplo:
.centrar {
text-align:center;
}
.aLaDerecha{
text-align:right;
}
line-height: sirve para medir la altura de la linea ejemplo:
.interlineado {
line-height: 1.6;
} 
text-decoration: sirve para decorar los textos ejemplo:
subrayado{
text-decoretion:none;
}
.tachado{
text-decoration:line-through;
}
estilo background:
background-color: sirve para cambiar los fondos de color ejemplo:
.fondoFuerte{
background-color:yellow;
}
background-image: sirve para tener de fondo una imagen ejemplo:
.catsandstars {
background-image: url("https://mdn.mozillademos.org/files/11991/startransparent.gif")
}
background-repeat sirve para repetir la imagen o no y donde ubicarlas ejemplo:
.ejemplo {
background-image: url("https://mdn.mozillademos.org/files/11991/startransparent.gif")
background-repeat: repeat-x,
                   repeat-y;
}
background-position sirve para posicionar una imagen ejemplo:
.ejemplo {
background-image: url("https://mdn.mozillademos.org/files/11991/startransparent.gif")
background-repeat: no-repeat;
background-position:right center;
}
background-size sirve para ocupar un espacio ejemplo:
.ejemplo {
background-image: url("https://mdn.mozillademos.org/files/11991/startransparent.gif")
background-repeat: no-repeat;
background-size:cover;
}

Unidades de Medida:Hay una amplia variedad de absolutas y relativas, pero nos centraremos en:
Absolutas
Px (pixels): es la unidad que usan las pantallas. 
Relativas
Rem: relativa a la configuración de tamaño de la raíz (etiqueta html). 
Porcentaje: tomando en cuenta que 16px es 100%.
Viewport: se utilizan para layouts responsivos (más adelante).

Tipografía web:Habíamos visto que usando “font-family”, es posible agregar algunas limitadas fuentes, pero... podemos usar muchísimas opciones de fuentes con “Google Fonts”.

Metodologia BEM:
BEM significa Modificador de Bloques de Elementos (Block Element Modifier) por sus siglas en inglés. 
Sugiere una manera estructurada de nombrar tus clases, basada en las propiedades del elemento en cuestión.
Se centra en tres parámetros o variables posibles: bloques (div, section, article, ul, ol, etc.), elementos (a, button, li, span, etc.) y modificadores. 
Bloque:El bloque es un contenedor o contexto donde el elemento se encuentra presente. Piensa como si fueran partes estructurales de código más grandes.
Elemento:El elemento es una de las piezas que compondrán la estructura de un bloque. El bloque es el todo, y los elementos son las piezas de este bloque.
Modificadores:Cuando necesitas modificar el estilo de un elemento específico, puedes usar un modificador. Para lograr esto, añade un doble guión -- luego del elemento (o bloque).
ejemplo: 
.block--modifier {}
.block__element--modifier {}
Todos los elementos del HTML son cajas.
Los elementos de linea ocupan solo espacio de su contenido por eso se verá uno al lado del otro.
Los elementos de bloque ocupan todo el espacio a lo ancho por eso aparece uno debajo del otro. 

Box model
Sin importar si son de línea o de bloque (pero tienen su incidencia en lo que sean), todas las etiquetas tienen propiedades en común.
CONTENT: el espacio para el texto o imagen.
PADDING: separación entre el borde y el contenido de la caja. Es un espacio interior.
BORDER: el límite entre el elemento y el espacio externo.
MARGIN: separación entre el borde y el afuera de la caja. Es un espacio exterior.

Propiedad para las cajas: Padding
box-sizing es un modificador que tiene dos modficadores border-box y content-box:
border-box: sirve para aumentar el padding de forma interna.
content-box: sirve para aumentar el padding de froma externa.

Alto y Ancho 
Ancho:Se denomina width a la propiedad CSS que controla la anchura de la caja de los elementos.
Alto: La propiedad CSS que controla la altura de la caja de los elementos se denomina height.

OverFlow
El modficador overflow sirve caundo un contenido desborda su caja por ejemplo cuando un texto sobresalo de su bloque, esto tiene 4 valores:
Visible: valor por defecto. El excedente es visible.  
Hidden: el excedente no se muestra (lo corta) →  recomendado.  
Scroll: genera una barra de scroll en los dos ejes (x/y) del elemento, aunque no se necesite.  
Auto: genera el scroll solo en el eje necesario.

Los espacios los lados tanto del Margin, Border o Padding se llaman de la misma maner y todas mantienen el mismo orden:
Las propiedades margin-top, margin-right, margin-bottom y margin-left se utilizan para definir los márgenes de cada uno de los lados del elemento por separado.
Las propiedades padding-top, padding-right, padding-bottom y padding-left se utilizan para definir los espacios internos de cada uno de los lados del elemento, por separado.
Las propiedades border-top, border-right, border-bottom, y border-left se utilizan para definir los bordes de cada lado del elemento por separado. A diferencia de los márgenes y padding, los bordes se forman con 3 valores:
Tipo de borde(border-style).
Grosor(-width).
Color(-color).
 
Display se encarga de definir cómo se ve un elemento HTML. Los dos comportamientos más importantes son: 
Pasar un elemento de bloque a uno de línea. 
Pasar un elemento de línea a uno de bloque.
Eso se hace con los valores block e inline respectivamente: 
Block: convierte el elemento en uno de bloque.
Inline: transforma el elemento en uno de línea.
Inline-block: Hay una propiedad que permite tomar lo mejor de ambos grupos, llamada “inline-block”. Brinda la posibilidad tener “padding” y “margin” hacia arriba y abajo.
¡Impotante!: los elemntos en línea no pueden tener width(ancho) y height(alto), solo pueden tener padding y margin solo a los costados.
tambien existe el display:none; es un un valor para quitar un elemento del layout,lo oculta, y además lo quita (no ocupa su lugar). 

Position
Es una propiedad CSS pensada para ubicar un elemento, con una libertad muy flexible. Algunos ejemplos de uso:
Superponer elementos.
Crear publicidades que te sigan con el scroll o un menú.
Hacer un menú con submenú adentro.
Para pasos para ubicar un elementos son 3:
1_Define qué tipo de posición quieres usar :
a) Position:Relative; El elemento es posicionado de acuerdo al flujo normal del documento, y luego es desplazado en relación a sí mismo.
b) Position:Absolute; El elemento es removido del flujo normal del documento, sin crearse espacio alguno para el mismo en el esquema de la página. 
Es posicionado relativo a su padre, siempre y cuando su padre tenga “position:relative”. De lo contrario, se ubica relativo al body. Se recomienda establecer un ancho y alto (width, height).
c) Position: Fixed; Esta posición es similar a la absoluta, con la excepción de que el elemento contenedor es el “viewport”, es decir, la ventana del navegador. 
Puede ser usada para crear elementos que floten, y que queden en la misma posición aunque se haga scroll. 
d) Position: Sticky; El elemento es posicionado en el “flow” natural del documento, podría decirse que es un valor que funciona de forma híbrida, es decir, como “relative” y también “fixed”. 
Esto es, cuando llega el “viewport” (la ventana del navegador) hasta donde se encuentra, se “pegará” sobre el borde superior.

Propiedad z-index
El z-index entra en juego cuando dos elementos que tienen position se superponen. Esta propiedad acepta como valor un número (sin ninguna unidad, ni px, ni cm, ni nada); a valor más alto, se mostrará por encima de los demás elementos. 
Por defecto, todos los objetos tienen z-index:1.

Flexbox
Con Flexbox ya no necesitarás usar float. Podrás posicionar y distribuir los elementos como tú quieras.
Es un conjunto de propiedades de CSS.
Se basa sobre un contenedor (padre) para ordenar a sus ítems (hijos).
No sólo se podrá posicionar elementos vertical y horizontalmente, sino que podrás establecer cómo se distribuirán, el orden que tendrán e incluso el tamaño en proporción a otros elementos.
Esto es perfecto para crear diseños adaptables a dispositivos móviles (Responsive Design)
Propiedades para aplicar en el contenedor flexible (el padre)
Para que podamos aplicar las propiedades en el contenedor flexible debemos iniciar con display:flex; esto indicara que sus hijos seran "flexibles".

flex-direction: (Elegir dirección vertical u horizontal)
row: Esta propiedad nos va a permitir especificar si queremos que los flex items se dispongan en filas o columnas.
row-reverse: Con el valor row-reverse (fila inversa) los flex items se apilan en una fila de derecha a izquierda.
column: Con el valor column, los flex items se apilan en una columna de arriba hacia abajo.
column-reverse: Con el valor column-reverse los flex items se apilan en una columna de abajo hacia arriba.

flex-wrap: (Con flex-wrap vamos a poder especificar si queremos que los ítems puedan saltar a una nueva línea si la dimenciones del contenedor cambian)
nowrap: este valor quiere decir es poder mantener los flex items en su eje, sin importar que las dimensiones de los mismos cambien.
wrap: Los flex items (hijos) pueden romper la línea del eje horizontal, si les es necesario para conservar las características de sus dimensiones. Esto es de izquierda a derecha, y de arriba a abajo.
wrap-reverse: Esta vez el orden es de izquierda a derecha, y de abajo a arriba.

flex-flow: Es la forma abreviada (shorthand) o rápida para las propiedades: 
👉 flex-direction
👉 flex-wrap
Se pone primero la propiedad de flex-direction, y luego la de flex-wrap.

justify-content: nos va a permitir alinear los elementos.
Esto puede ser de forma vertical u horizontal, según lo especifiquemos con flex-direction.
Nos va a ayudar a distribuir los flex items (hijos) en el contenedor (padre), cuando los ítems no utilicen todo el espacio disponible en su eje principal actual. 
¡Los siguientes ejemlos parten de la base del contenedor en “row"!
flex-start: Consiste en alinear los flex items (hijos) al lado izquierdo.
flex-end: Consiste en alinear los flex items (hijos) al lado derecho.
center: Consiste en alinear los flex items (hijos) al centro.
space-betweem: Es hacer que los flex items (hijos) tomen la misma distancia o espaciado entre ellos dentro del contenedor flexible, quedando el primer y último elemento pegados con los bordes del contenedor en el eje principal.
space-around: Muestra los flex items (hijos) con el mismo espacio de separación entre sí. 
El espaciado entre los bordes lo toman del contenedor padre.
space-evenly: Hace que el espacio entre los flex items (hijos) sea igual. No es lo mismo que space-around.
¡Lo mismo seria si la base del contenedor seria "column"!

align-items: Alinear los elementos verticales de forma horizontal o Alinear los elementos horizontales de forma vertical.
stretch: Tratará de llenar toda la altura (o anchura) del contenedor, siempre y cuando los hijos no tengan propiedades de dimensión definidas.
flex-start: alinea los items en la parte de arriba
flex-end: alinea los items en la parte de abajo
center: alinea los items en la parte central 
baseline: alinea los elemntos de por la base de los textos sin importar el tamaño de la cajas de los items:

align-content: Esta propiedad sólo tiene efecto cuando el contenedor flexible tiene varias líneas de flex items (hijos). 
Si se colocan en una sola línea, esta propiedad no tiene ningún efecto sobre el diseño.
Para poder aplicarlo se necesita tener el atributo flex-wrap, que permita verificar los ejes horizontales.
stretch: hace que los items ocupen todo el alto del contenedor 
flex-start: acomoda todas las filas en la parte de arriba del contenedor
flex-end: acomoda todas las filas en la parte de abajo del contenedor
center: acomoda las filas en el centre del contenedor 
space-between: Acomoda las filas tales que queden en la parte de arriba y abajo dejando un espacio en el centro
space-around: acomoda las filas dejando espacios entre las filas y poco espacio con los borde de arriba y abajo
space-evenly: acomoda las filas dejando espacios iguales entre ellas incluso entre los bordes de arriba y abajo 

Propiedades para los items

align-self: sirve para dale valor a un item el caul queremos usar cambiando el comportamiento del align-items
flex-start, flex-end, center, baseline y strech.

flex-grow: esta propiedad permite indicar el factor de crecimiento de los items en el caso de tener un ancho especifico, segun el valor que le coloquemos a los diferentes items 
estos empesando desde 0 (siendo el valor mas pequeño y el que ocupa menos espacio).

flex-shrink: esta propiedad es la opuesta a flex-grow. Mientras que la anterior indica un factor de crecimiento flex-shrink hace justo lo contrario siendo el valor mayor el que ocupe menos espacio.

order: esta porpiedad sirve para modificar el orden de como se muestra. Si indicamos un order con un valor numerico, ira recolocando los items segun su numero,
colocando antes los items con numeros mas pequeños(incluyendo valores negativos) y despues los items con numeros mas altos.

Grids:
CSS Grid es el sistema de maquetación más potente que hay disponible. Se trata de un sistema en 2D que permite definir filas y columnas (a diferencia de Flexbox, el cual funciona en una única dimensión). 
El CSS grid se puede utilizar para lograr muchos diseños diferentes. Se destaca por dividir una página en regiones principales, o definir la relación en términos de tamaño, posición y capas, entre partes de un control.
Siendo mas claros Grids no viene a remplazar a flexbox, ambos se utilizan para poder crear diseños mas complejos y completos. Podriamos decir que grids fue creada para diseñar el layaout 
(layout sirve para hacer referencia a la manera en que están distribuidos los elementos y las formas dentro de un diseño) y flexbox para los componentes.
Propiedades del padre:
Activamos la cuadrícula Grid utilizando, sobre el elemento contenedor, la propiedad display con el valor grid o inline-grid.
grid:El primero de ellos permite que la aquella aparezca encima/debajo del contenido exterior (en bloque)
inline-grid: cuadrícula se vea a la izquierda/derecha (en línea) del contenido exterior.

Display:grid incluye los siguientes modificadores:
grid-template-columns: Establece el TAMAÑO de cada columna.
grid-template-rows: Establece el TAMAÑO de cada fila.
Las filas y columnas se pueden crear de forma explicitas:
por ejemplo:
grid-templete-columns: 23px 30px /*se crean dos columnas*/
Tambien se pueden crear en fracciones:
por ejemplo:
grid-tamplate-columns: 2fr 1fr;
Filas y columnas repetitivas:
Si necesitas hacer muchas columnas y filas iguales
grid-template-columns: repeat(12, 1fr); /*Se crean 12 columnas de 1fr de tamaño cada una*/

Grid por areas: Es posible indicar el nombre y la posición concreta de cada área de la cuadrícula. Utiliza la propiedad grid-template-areas, donde debes especificar el orden de las áreas. Luego, en cada ítem hijo, 
usas la propiedad grid-area para indicar el nombre del área en cuestión.

grid espacios:La cuadrícula tiene todas sus celdas una a continuación de la otra. 
Aunque sería posible darle un margen a las celdas dentro del contenedor

Posicion de hijos:
Es posible distribuir los elementos de una forma muy sencilla y cómoda: justify-items y align-items, que ya conocemos del módulo CSS Flexbox: 
justify-items:Valores:start|end|center|strech  Distribuye los elemntos en el eje horizontal.
align-items:Valores:start|end|center|strech    Distribuye los elemntos en el eje vertical.
Posicion de elementos:
Es posible utilizar las propiedades justify-content o align-content para cambiar la distribución de todo el contenido en su conjunto. 
justify-content: Valores: start|end|center|stretch|space-around|space-between|space-evenly afecata a eje horizontal 
align-content: Valores: start|end|center|stretch|space-around|space-between|space-evenly  afecta a eje vertical

Items propiedades 
Hasta ahora hemos visto propiedades CSS que se aplican solamente al contenedor padre de una cuadrícula. 
Ahora vamos a ver ciertas propiedades que se aplican a cada ítem hijo de la cuadrícula, para alterar o cambiar el comportamiento específico de dicho elemento.
Prueba sus propiedades aquí.
justify-self: Altera la justificación del ítem hijo en el eje horizontal.
align-self: Altera la alineación del ítem hijo en el eje vertical.
grid-area: Indica un nombre al área especificada, para su utilización con grid-template-areas.

Grid II:
Diseño responsive: se refiere a la idea de que un sitio web debería mostrarse igual de bien en todo tipo de dispositivo, desde monitores de pantalla panorámica hasta teléfonos móviles. 
El diseño responsive se logra a través de "Media Queries" de CSS. Pensemos en las Media Queries como una forma de aplicar condicionales a las reglas de CSS.
Mobile First: significa crear el código primero para los dispositivos más pequeños que los usuarios probablemente tengan, como teléfonos o tabletas. Implica trabajar en el dispositivo más pequeño, 
y luego acumular desde allí todo en el mismo código y el mismo proyecto, en lugar de hacer uno nuevo para cada tamaño de pantalla.
Meta Viewpoint:Usa la etiqueta <meta> viewport para controlar el ancho y el ajuste de la ventana de visualización del navegador.
Incluye width=device-width para hacer coincidir el ancho de la pantalla en píxeles independientes del dispositivo.
Usa initial-scale=1 para establecer una relación de 1:1 entre los píxeles CSS y los píxeles independientes del dispositivo.

Categorias - Breack Points:
320px: Para dispositivos con pantallas pequeñas, como los teléfonos en modo vertical
480px: Para dispositivos con pantallas pequeñas, como los teléfonos, en modo horizontal
600px: Tabletas pequeñas, como el Amazon Kindle (600×800) y Barnes & Noble Nook (600×1024), en modo vertical
768px y 1023px: Tabletas de diez pulgadas como el iPad (768×1024), en modo vertical
1024px: Tabletas como el iPad (1024×768), en modo horizontal, así como algunas pantallas de ordenador portátil, netbook, y de escritorio
1200px: Para pantallas panorámicas, principalmente portátiles y de escritorio


Animaciones:
Gradientes, transformaciones, Transiciones y Animaciones. 
¡Importante! Para entender los valores que debemos aplicar, es necesario comprender el concepto de los ejes.
X se refiere a la posición horizontal, de izquierda a derecha.
Y se refiere a la posición vertical, de arriba hacia abajo.
Z puedes también mover los elementos hacia adelante o atrás en el documento (2D), como si se tratara de un espacio 3D.

Gradientes: En el gradiente lineal, la transformación de color va avanzando línea a línea; mientras que en el radial, dicha transformación se produce debido a que sucesivos círculos concéntricos van cambiando de color.
Los gradientes en CSS son de dos tipos: lineales (linear-gradient) y radiales (radial-gradient). 
Puedes elegir el punto de inicio del gradiente. Los puntos de inicio pueden ser top, right, left o bottom de tu caja, o puedes escoger los grados de inclinación que quieres que tenga tu gradiente.
ejemplo:
.clase {
 background-image: linear-gradient(to left, red , yellow);
}


Transformaciones: Una transformación es una modificación de la forma en que se muestra un elemento. Todo elemento transformado por CSS cambia la forma en que se ve, pero no el lugar que ocupa. Los efectos que se pueden lograr son:  
Mover un elemento de lugar (¡sin position!): cambia la ubicación del objeto (como si fuese un position).
Requiere dos números y su unidad, separados por una coma:  
El primero es el desplazamiento horizontal (eje X).
El segundo el desplazamiento vertical (eje Y). 
Valores positivos mueven a la derecha/abajo.
Valores negativos mueven a la izquierda/arriba.  
Sí, existe translateX() y translateY(), cada uno sólo recibe un número con su unidad.
ejemplo:
div {
   transform: translate(10px, 20px);
}
Escalar el tamaño de un elemento: cambia la escala del objeto (como si fuese un zoom)
Requiere dos números separados por coma:  
El primero es el ancho (Escala en eje X).  
El segundo el es alto (Escala en eje Y). 
Valores mayores a 1, agrandan. 
Valores entre 1 y 0, achican. 
Valores negativos, escalan dado vuelta.  
Si solo se quiere cambiar un eje, existe scaleX() y scaleY(), cada uno solo recibe un número.
ejemplo:
div {
   transform: scale(2,1);
}
Voltear y girar elementos:La rotación permite girar un objeto sin deformarlo. Recibe entre paréntesis un número que representa la cantidad de grados a girar el objeto: 
Si es positivo, rota hacia la derecha (en sentido horario).  
Si es negativo, rota hacia la izquierda (sentido antihorario).  
Por tratarse de grados, la unidad que acompaña el número será deg (degrees).
ejemplo:
div {
   transform: rotate(360deg);
}
Cambiar la perspectiva de un elemento: transform:skew( ), para deformar objetos en el CSS utilizamos el método skew (sesgar). 
Puede tener hasta dos números separados por coma:  
Sus parámetros son los ángulos de deformación en grados sexagesimales (deg).  
El primero indica el eje  “X”.
El segundo indica el eje “Y”.
ejemplo:
div {
   transform: skew(20deg,10deg);
}


Transiciones:Con la propiedad transition, es posible lograr que al pasar el mouse por el elemento, el mismo “haga una animación”. 
es importante utilizar :hover y se puede utilizar en cualquier elemento.
Para usar las transiciones debemos indicar que propiedad queremos que se animen y por cuanto segundos 
ejemplo:
div {
   width: 100px;
   height: 100px;
   transition: height 2s, width 1s;       
}
div:hover {
   height: 200px; width: 200px;
}
Tambien se puede aplicar la transiciones a todas las priedades que haya variado 
ejemplo:
div {
   width: 100px; height: 100px;
   transition: all 2s;       
}
div:hover {
   height: 200px; width: 200px;
   padding: 20px;
   background-color: cyan;
}

Animaciones:A diferencia de la transición, una animación es un efecto que se loopea tantas veces como se quiera.
Es la unión de dos partes:  por un lado, una línea de tiempo (llamada keyframe) con la información de los cambios; 
por otro, aplicar ese keyframe a un elemento que será el que se verá animado.
Es un elemento @keyframes leo {aca iria el codigo css} con un nombre. Luego del nombre y entre llaves, se definen los puntos donde cambiará el CSS.  
ejemplo:
section {
   width: 100px;
   height: 100px;
   background-color: green;
   animation-name: un_efecto;
   animation-iteration-count: infinite;
   animation-timing-function: ease-in;
   animation-duration: 2s;
   animation-delay: 10s;
}

@keyframes un_efecto {
   0%{ width: 100px; }
   0.2s{ width: 50px; }
   25%{ width: 300px; }
   50%{ width: 200px;
     background-color: red; }
   75%{ width: 300px;}
   100%{ width: 100px;
     background-color:green;}
}
¡impotante! Las animaciones se pueden utilizar de muchas paginas 




